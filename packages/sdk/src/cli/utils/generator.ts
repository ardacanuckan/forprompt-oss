/**
 * Prompt File Generator
 *
 * Generates the forprompt/ folder structure with prompts
 *
 * Structure:
 * forprompt/
 * ├── .forpromptrc           # Project config
 * ├── index.ts               # Main export file
 * ├── userContextPrompt/
 * │   ├── prompt.ts          # Exported prompt constant
 * │   ├── metadata.json      # Version info, timestamps
 * │   └── versions/
 * │       ├── v1.md          # Historical versions
 * │       └── v2.md
 * └── chatDefaultPrompt/
 *     ├── prompt.ts
 *     └── metadata.json
 */

import * as fs from "fs";
import * as path from "path";
import type { PromptData } from "./api";

/**
 * Generate the forprompt folder structure
 */
export function generatePromptFiles(
  prompts: PromptData[],
  outputDir: string
): { created: number; updated: number } {
  let created = 0;
  let updated = 0;

  // Ensure output directory exists
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Generate files for each prompt
  for (const prompt of prompts) {
    const promptDir = path.join(outputDir, prompt.key);
    const versionsDir = path.join(promptDir, "versions");

    // Create directories
    if (!fs.existsSync(promptDir)) {
      fs.mkdirSync(promptDir, { recursive: true });
      created++;
    } else {
      updated++;
    }

    if (!fs.existsSync(versionsDir)) {
      fs.mkdirSync(versionsDir, { recursive: true });
    }

    // Generate prompt.ts
    generatePromptFile(prompt, promptDir);

    // Generate metadata.json
    generateMetadataFile(prompt, promptDir);

    // Generate version history files
    generateVersionFiles(prompt, versionsDir);
  }

  // Generate index.ts that exports all prompts
  generateIndexFile(prompts, outputDir);

  return { created, updated };
}

/**
 * Generate prompt.ts file
 */
function generatePromptFile(prompt: PromptData, promptDir: string): void {
  const activeVersion = prompt.activeVersion;
  if (!activeVersion) return;

  const content = `/**
 * ${prompt.name}
 * ${prompt.description || ""}
 *
 * Version: ${activeVersion.versionNumber}
 * Last updated: ${new Date(activeVersion.updatedAt).toISOString()}
 *
 * @generated by ForPrompt CLI - Do not edit manually
 */

export const ${prompt.key} = ${JSON.stringify(activeVersion.systemPrompt)};

export const ${prompt.key}Info = {
  key: "${prompt.key}",
  name: "${prompt.name}",
  version: ${activeVersion.versionNumber},
  updatedAt: ${activeVersion.updatedAt},
} as const;

export default ${prompt.key};
`;

  fs.writeFileSync(path.join(promptDir, "prompt.ts"), content);
}

/**
 * Generate metadata.json file
 */
function generateMetadataFile(prompt: PromptData, promptDir: string): void {
  const metadata = {
    key: prompt.key,
    name: prompt.name,
    description: prompt.description,
    activeVersion: prompt.activeVersion?.versionNumber || null,
    totalVersions: prompt.versions.length,
    purpose: prompt.purpose,
    expectedBehavior: prompt.expectedBehavior,
    inputFormat: prompt.inputFormat,
    outputFormat: prompt.outputFormat,
    constraints: prompt.constraints,
    useCases: prompt.useCases,
    additionalNotes: prompt.additionalNotes,
    toolsNotes: prompt.toolsNotes,
    tools: prompt.tools,
    createdAt: prompt.createdAt,
    updatedAt: prompt.updatedAt,
    lastDeployedAt: Date.now(),
  };

  fs.writeFileSync(
    path.join(promptDir, "metadata.json"),
    JSON.stringify(metadata, null, 2)
  );
}

/**
 * Generate version history files
 */
function generateVersionFiles(prompt: PromptData, versionsDir: string): void {
  for (const version of prompt.versions) {
    const filename = `v${version.versionNumber}.md`;
    const content = `# Version ${version.versionNumber}
# Created: ${new Date(version.createdAt).toISOString()}
${version.description ? `# ${version.description}\n` : ""}
${version.systemPrompt}`;

    fs.writeFileSync(path.join(versionsDir, filename), content);
  }
}

/**
 * Generate index.ts that exports all prompts
 */
function generateIndexFile(prompts: PromptData[], outputDir: string): void {
  const exports = prompts
    .filter((p) => p.activeVersion)
    .map((p) => `export { ${p.key}, ${p.key}Info } from "./${p.key}/prompt";`)
    .join("\n");

  const promptMap = prompts
    .filter((p) => p.activeVersion)
    .map((p) => `  "${p.key}": ${p.key},`)
    .join("\n");

  const imports = prompts
    .filter((p) => p.activeVersion)
    .map((p) => p.key)
    .join(", ");

  const content = `/**
 * ForPrompt - Auto-generated prompt exports
 *
 * @generated by ForPrompt CLI - Do not edit manually
 * Generated at: ${new Date().toISOString()}
 */

${exports}

import { ${imports} } from "./";

/**
 * All prompts as a map for dynamic access
 */
export const prompts = {
${promptMap}
} as const;

/**
 * Get a prompt by key
 */
export function getPrompt(key: keyof typeof prompts): string {
  return prompts[key];
}

export type PromptKey = keyof typeof prompts;
`;

  fs.writeFileSync(path.join(outputDir, "index.ts"), content);
}

/**
 * Clean up removed prompts (prompts that exist locally but not in the server)
 */
export function cleanupRemovedPrompts(
  serverPrompts: PromptData[],
  outputDir: string
): string[] {
  const removed: string[] = [];
  const serverKeys = new Set(serverPrompts.map((p) => p.key));

  if (!fs.existsSync(outputDir)) return removed;

  const entries = fs.readdirSync(outputDir, { withFileTypes: true });

  for (const entry of entries) {
    // Skip non-directories and special files
    if (!entry.isDirectory()) continue;
    if (entry.name.startsWith(".")) continue;

    if (!serverKeys.has(entry.name)) {
      const promptDir = path.join(outputDir, entry.name);
      fs.rmSync(promptDir, { recursive: true, force: true });
      removed.push(entry.name);
    }
  }

  return removed;
}
